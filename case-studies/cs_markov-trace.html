<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Taller de análisis de decisiones - Case Study: Construct a Markov Trace</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../site_libs/font-awesome-5.13.0/js/script.js"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Taller de análisis de decisiones</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">Instructores</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../case-studies/2024_chds_amua_tutorials_tp.pdf"> 
<span class="menu-text">Recursos Amua</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Case Study: Construct a Markov Trace</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="cell">
<div class="cell-output-display">
<a href="https://graveja0.github.io/v-brch-nigeria-2023/case-studies/healthy-sick-dead-DALY_BLANK.xlsx">
<button class="btn btn-primary"><i class="fa fa-save"></i> Download Case Study Excel File</button>
</a>
</div>
</div>
<style>
.nobullet li {
  list-style-type: none;
}
</style>
<section id="introduction-and-learning-objectives" class="level1">
<h1>Introduction and Learning Objectives</h1>
<p>This case study is designed to get you familiar with conducting Markov modeling in Excel. Specific learning objectives are as follows:</p>
<ol type="1">
<li><p>Parameterize and structure a Markov model.</p></li>
<li><p>Construct a Markov trace.</p></li>
</ol>
</section>
<section id="overview-of-decision-problem" class="level1">
<h1>Overview of Decision Problem</h1>
<p>Noncommunicable diseases (NCDs) have emerged as a dominant issue in global health, significantly contributing to the overall disease and mortality burden worldwide. Cardiovascular diseases (CVDs) are at the forefront of this change, accounting for a substantial portion of morbidity and mortality, particularly in low- and middle-income countries (LMICs).</p>
<p>In Nigeria, as in many other LMICs, this upsurge poses a significant public health challenge, exacerbating the strain on healthcare systems already grappling with infectious and other noncommunicable diseases.</p>
<p>The development of a Markov model for cardiovascular disease in this context provides an invaluable tool for understanding disease progression, informing public health strategies, and guiding resource allocation to combat this growing crisis effectively.</p>
<p>In this case study, we will draw on data and parameters from the Global Burden of Disease (GBD) study to construct a Markov model of CVD.</p>
<section id="model-structure" class="level2">
<h2 class="anchored" data-anchor-id="model-structure">Model Structure</h2>
<p>We will construct progressive CVD model in which healthy individuals develop CVD, which is captured by two health states (“Sick” and “Sicker”). These health states could, for example, correspond to living with episodes of angina and living in a post- myocardial infarction state.</p>
<p>Both healthy and sick patients can also transition to an absorbing death state due to causes unrelated to the disease (i.e., “background” mortality). For those with CVD, those in the “Sick” and “Sicker” states can transition to a separate death state if they experience death due to CVD-related causes (e.g., fatal MI). Separating out deaths from background causes and from CVD will be important later, when we want to calculate DALYs and DALYs averted from different interventions.</p>
<p>A “bubble” or state transition diagram for our Markov model is shown in <a href="#fig-model" class="quarto-xref">Figure&nbsp;1</a>.</p>
<div class="cell" data-fig-width="6" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-model" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<svg width="576" height="480" viewbox="0.00 0.00 499.83 270.59" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 266.59)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-266.59 495.83,-266.59 495.83,4 -4,4"></polygon>
<!-- Healthy -->
<g id="node1" class="node">
<title>Healthy</title>
<ellipse fill="none" stroke="black" cx="59.61" cy="-221.3" rx="41.71" ry="18"></ellipse>
<text text-anchor="middle" x="59.61" y="-217.1" font-family="Times,serif" font-size="14.00">Healthy</text>
</g>
<!-- Healthy&#45;&gt;Healthy -->
<g id="edge1" class="edge">
<title>Healthy:w-&gt;Healthy:w</title>
<path fill="none" stroke="black" d="M17.61,-221.3C12,-230.3 0,-230.3 0,-221.3 0,-215.67 4.69,-213.56 9.57,-214.97"></path>
<polygon fill="black" stroke="black" points="7.58,-217.86 17.61,-221.3 11.92,-212.36 7.58,-217.86"></polygon>
</g>
<!-- Sick -->
<g id="node2" class="node">
<title>Sick</title>
<ellipse fill="none" stroke="black" cx="167.61" cy="-149.3" rx="28.41" ry="18"></ellipse>
<text text-anchor="middle" x="167.61" y="-145.1" font-family="Times,serif" font-size="14.00">Sick</text>
</g>
<!-- Healthy&#45;&gt;Sick -->
<g id="edge5" class="edge">
<title>Healthy-&gt;Sick</title>
<path fill="none" stroke="black" d="M82.51,-206.03C99.07,-194.99 121.54,-180.01 139.23,-168.21"></path>
<polygon fill="black" stroke="black" points="141.61,-170.83 147.99,-162.37 137.73,-165.01 141.61,-170.83"></polygon>
</g>
<!-- Dead -->
<g id="node5" class="node">
<title>Dead</title>
<ellipse fill="none" stroke="black" cx="383.61" cy="-221.3" rx="90.44" ry="41.09"></ellipse>
<text text-anchor="middle" x="383.61" y="-233.9" font-family="Times,serif" font-size="14.00">Death from</text>
<text text-anchor="middle" x="383.61" y="-217.1" font-family="Times,serif" font-size="14.00">Background Causes</text>
<text text-anchor="middle" x="383.61" y="-200.3" font-family="Times,serif" font-size="14.00">(DeadBG)</text>
</g>
<!-- Healthy&#45;&gt;Dead -->
<g id="edge6" class="edge">
<title>Healthy-&gt;Dead</title>
<path fill="none" stroke="black" d="M101.3,-221.3C146.96,-221.3 221.82,-221.3 282.98,-221.3"></path>
<polygon fill="black" stroke="black" points="283.06,-224.8 293.06,-221.3 283.06,-217.8 283.06,-224.8"></polygon>
</g>
<!-- Sick&#45;&gt;Sick -->
<g id="edge3" class="edge">
<title>Sick:w-&gt;Sick:w</title>
<path fill="none" stroke="black" d="M139.61,-149.3C133.4,-158.3 121.4,-158.3 121.4,-149.3 121.4,-143.53 126.33,-141.46 131.5,-143.08"></path>
<polygon fill="black" stroke="black" points="129.54,-145.99 139.61,-149.3 133.8,-140.43 129.54,-145.99"></polygon>
</g>
<!-- Sicker -->
<g id="node3" class="node">
<title>Sicker</title>
<ellipse fill="none" stroke="black" cx="275.61" cy="-149.3" rx="35.92" ry="18"></ellipse>
<text text-anchor="middle" x="275.61" y="-145.1" font-family="Times,serif" font-size="14.00">Sicker</text>
</g>
<!-- Sick&#45;&gt;Sicker -->
<g id="edge7" class="edge">
<title>Sick-&gt;Sicker</title>
<path fill="none" stroke="black" d="M195.98,-149.3C206.22,-149.3 218.06,-149.3 229.43,-149.3"></path>
<polygon fill="black" stroke="black" points="229.68,-152.8 239.68,-149.3 229.68,-145.8 229.68,-152.8"></polygon>
</g>
<!-- DeadDisease -->
<g id="node4" class="node">
<title>DeadDisease</title>
<ellipse fill="none" stroke="black" cx="221.61" cy="-41.3" rx="69.66" ry="41.09"></ellipse>
<text text-anchor="middle" x="221.61" y="-53.9" font-family="Times,serif" font-size="14.00">Death From</text>
<text text-anchor="middle" x="221.61" y="-37.1" font-family="Times,serif" font-size="14.00">Disease</text>
<text text-anchor="middle" x="221.61" y="-20.3" font-family="Times,serif" font-size="14.00">(DeadDisease)</text>
</g>
<!-- Sick&#45;&gt;DeadDisease -->
<g id="edge10" class="edge">
<title>Sick-&gt;DeadDisease</title>
<path fill="none" stroke="black" d="M176.28,-131.94C181.96,-120.59 189.69,-105.13 197.15,-90.21"></path>
<polygon fill="black" stroke="black" points="200.4,-91.53 201.74,-81.02 194.14,-88.4 200.4,-91.53"></polygon>
</g>
<!-- Sick&#45;&gt;Dead -->
<g id="edge9" class="edge">
<title>Sick-&gt;Dead</title>
<path fill="none" stroke="black" d="M192.81,-157.7C219.28,-166.52 262.33,-180.87 300.84,-193.71"></path>
<polygon fill="black" stroke="black" points="299.93,-197.09 310.52,-196.93 302.14,-190.45 299.93,-197.09"></polygon>
</g>
<!-- Sicker&#45;&gt;Sicker -->
<g id="edge4" class="edge">
<title>Sicker:e-&gt;Sicker:e</title>
<path fill="none" stroke="black" d="M311.61,-149.3C317.31,-158.3 329.31,-158.3 329.31,-149.3 329.31,-143.67 324.63,-141.56 319.72,-142.97"></path>
<polygon fill="black" stroke="black" points="317.34,-140.38 311.61,-149.3 321.64,-145.9 317.34,-140.38"></polygon>
</g>
<!-- Sicker&#45;&gt;DeadDisease -->
<g id="edge11" class="edge">
<title>Sicker-&gt;DeadDisease</title>
<path fill="none" stroke="black" d="M266.69,-131.46C261.03,-120.15 253.42,-104.92 246.06,-90.2"></path>
<polygon fill="black" stroke="black" points="249.13,-88.52 241.53,-81.14 242.87,-91.65 249.13,-88.52"></polygon>
</g>
<!-- Sicker&#45;&gt;Dead -->
<g id="edge8" class="edge">
<title>Sicker-&gt;Dead:s</title>
<path fill="none" stroke="black" d="M306.84,-158.26C329.52,-164.77 358.75,-173.16 373.76,-177.47"></path>
<polygon fill="black" stroke="black" points="373.03,-180.9 383.61,-180.3 374.96,-174.17 373.03,-180.9"></polygon>
</g>
<!-- DeadDisease&#45;&gt;DeadDisease -->
<g id="edge12" class="edge">
<title>DeadDisease:e-&gt;DeadDisease:e</title>
<path fill="none" stroke="black" d="M291.61,-41.3C297.19,-50.3 309.19,-50.3 309.19,-41.3 309.19,-35.67 304.5,-33.56 299.62,-34.97"></path>
<polygon fill="black" stroke="black" points="297.29,-32.35 291.61,-41.3 301.62,-37.84 297.29,-32.35"></polygon>
</g>
<!-- Dead&#45;&gt;Dead -->
<g id="edge2" class="edge">
<title>Dead:e-&gt;Dead:e</title>
<path fill="none" stroke="black" d="M474.61,-221.3C479.83,-230.3 491.83,-230.3 491.83,-221.3 491.83,-215.81 487.37,-213.67 482.71,-214.87"></path>
<polygon fill="black" stroke="black" points="480.26,-212.34 474.61,-221.3 484.62,-217.82 480.26,-212.34"></polygon>
</g>
</g>
</svg>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: State transition diagram for progressive CVD model.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="model-strategies" class="level2">
<h2 class="anchored" data-anchor-id="model-strategies">Model Strategies</h2>
<p>We will first build a “natural history” model that captures the status quo. We’ll then consider the cost-effectiveness of several prevention and treatment strategies under consideration.</p>
<table class="table">
<caption>Strategies</caption>
<colgroup>
<col style="width: 32%">
<col style="width: 45%">
<col style="width: 16%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Strategy</th>
<th>Benefit</th>
<th>Cost</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>NH</strong>: Natural History (“Status Quo”)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>A:</strong> Prevention Strategy</td>
<td><p>Prevents transitions from Healthy to CVD health state.</p>
<p>Relative Risk (RR) = 0.98</p></td>
<td>Annual cost of 50</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>B:</strong> Prevention Strategy</td>
<td><p>Prevents transitions from Healthy to CVD health state.</p>
<p>Relative Risk (RR) = 0.9</p></td>
<td>Annual cost of 150</td>
<td></td>
</tr>
<tr class="even">
<td><strong>C:</strong> Prevention Strategy</td>
<td><p>Prevents transitions from Healthy to CVD health state.</p>
<p>Relative Risk (RR) = 0.95</p></td>
<td>Annual cost of 250</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>D:</strong> Treatment Strategy</td>
<td><p>Prevents deaths from CVD.</p>
<p>Relative Risk of Death = 0.50</p></td>
<td>Annual cost of 400</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="other-model-parameters" class="level2">
<h2 class="anchored" data-anchor-id="other-model-parameters">Other Model Parameters</h2>
<p>Our model will be constructed using the following parameters and assumptions:</p>
<ul>
<li>Initial cohort of 20 year olds who we follow over a 60 year time horizon.</li>
<li>Annual (yearly) cycle length.</li>
<li>Annual discount rate of 3% for both costs and health outcomes.</li>
<li>Background mortality rates are based on GBD 2019 estimates.</li>
<li>CVD incidence and mortality rates are based on GBD 2019 estimates.</li>
<li>Disability weights (for YLDs in DALY outcomes)
<ul>
<li>Sick: 0.10</li>
<li>Sicker: 0.20</li>
</ul></li>
<li>Utility weights (for QALY outcomes):
<ul>
<li>Healthy: 1.0</li>
<li>Sick: 0.98</li>
<li>Sicker: 0.8</li>
</ul></li>
<li>Transition probabilities are based on GBD 2019 estimates, but for the sake of simplicity, are held fixed over cycles/time.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li>
<li>A cycle spent in the “Sick” state incurs a cost of 1,000.</li>
<li>A cycle spent in the “Sicker” state incurs a cost of 1,000.</li>
</ul>
<div class="callout callout-style-simple callout-none no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>Note that some of these parameters have been set for didactic purposes; they do not necessarily correspond to the values one might use if constructing a “real world” CVD model.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>You may notice that there are two versions of each disability weight—one (e.g., <code>dwS1_unadj</code>) that is unadjusted and shaded in the green area, and one (e.g., <code>dwS1_</code>) that is calculated using a formula and shaded in the red area. The formula applied is simply applying continuous time discounting within the cycle. You do not necessarily have to do this (the values are very similar), but this step is necessary to formally match the approach to calculating YLDs based on the formulas used by the GBD.</p>
</div>
</div>
</div>
</section>
<section id="parameters-in-excel-model" class="level2">
<h2 class="anchored" data-anchor-id="parameters-in-excel-model">Parameters in Excel Model</h2>
<p>If you open the Excel file, you will see that the model is constructed in a series of Worksheets. The first Worksheet, “Parameters”, contains the model parameters as described above.</p>
<p>The parameters shaded with green are fixed; we simply put in a “base case” value. The parameters in red are constructed based on formulas; they take as inputs one or more of the green-shaded parameters, and apply a formula to get a new value. The specific formula is provided in the “Formula” column.</p>
<p><img src="images/cs_markov-parameters.png" class="img-fluid quarto-figure quarto-figure-center"> … <img src="images/cs_markov-parameters2.png" class="img-fluid quarto-figure quarto-figure-center"></p>
</section>
</section>
<section id="part-1-construct-transition-probability-matrices" class="level1">
<h1>Part 1: Construct Transition Probability Matrices</h1>
<p>In this part, we will use the supplied transition probabilities (in the “Parameters” worksheet) to construct transition probability matrices for each strategy.</p>
<section id="step-1-define-parameter-names" class="level2">
<h2 class="anchored" data-anchor-id="step-1-define-parameter-names">Step 1: Define Parameter Names</h2>
<p><em>Assign variable names to each parameter in the “Parameters” worksheet.</em></p>
<div class="callout callout-style-simple callout-none no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>Recall that we covered several methods to assign variable names on Day 1 (Monday) in the Decision Tree Excel Case Study. You can use any of these methods to assign variable names to the parameters in the “Parameters” worksheet.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Define variable names for the fixed (green) parameters first, then for the formula-based (red) parameters second.</p>
</div>
</div>
</section>
<section id="step-2-construct-the-transition-probability-matrix" class="level2">
<h2 class="anchored" data-anchor-id="step-2-construct-the-transition-probability-matrix">Step 2: Construct the Transition Probability Matrix</h2>
<p><em>Open the second worksheet (“transition_matrices”) and construct a transition probability matrix for each strategy.</em></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>You can simply use the transition probability parameters for the Natural History (NH) strategy. For the other intervention-based strategies, you’ll need to use the supplied transition probabilities, <em>but also</em> incorporate the appropriate relative risks (“rr_”) for each strategy. You can do this by multiplying the transition probability by the relative risk parameter.</p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you encounter a cell where there is no defined probability (e.g., a transition from Sick back to Healthy), simply enter a value of 0.</p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Once in a death state, individuals must remain in the death state. So the transition probability from DeadBG -&gt; DeadBG must be set to 1.0, and the transition probability for DeadDisease -&gt; DeadDisease must also be 1.0.</p>
<p>Relatedly, and more generally, remember that each row of the transition probability matrix must sum to 1.0. That means you can define the diagonal elements (shaded in red) as 1 minus the other transition probabilities in the row.</p>
</div>
</div>
</section>
<section id="step-3-name-the-transition-probability-matrix" class="level2">
<h2 class="anchored" data-anchor-id="step-3-name-the-transition-probability-matrix">Step 3: Name the Transition Probability Matrix</h2>
<p><em>Once you have the transition probabilities filled in for each strategy, select each matrix and name it using the name supplied the “matrix_name” column. Repeat this process for all strategies under consideration</em></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>For this exercise, you’ll be selecting a <em>region</em> of cells (i.e., the transition matrix values) and naming that region. You can do this using the <em>Define Name</em> box in the <em>Formulas</em> tab.</p>
</div>
</div>
<p><img src="images/cs_markov-name-matrix1.png" class="img-fluid quarto-figure quarto-figure-center"> <img src="images/cs_markov-name-matrix2.png" class="img-fluid quarto-figure quarto-figure-center"></p>
</section>
<section id="step-4-insert-the-transition-probability-matrix-into-each-strategy-worksheet" class="level2">
<h2 class="anchored" data-anchor-id="step-4-insert-the-transition-probability-matrix-into-each-strategy-worksheet">Step 4: Insert the Transition Probability Matrix into Each Strategy Worksheet</h2>
<p>Next, open up the “NH” worksheet. This is the worksheet where we will construct the Markov trace and perform all the calculations to calculate cost, QALY, and DALY outcomes.</p>
<p><em>Insert the transition probability matrix for the NH strategy into the space reserved for the transition matrix in the NH worksheet</em></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/cs_markov-insert-matrix.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="images/cs_markov-insert-matrix.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></a></p>
</figure>
</div>
</section>
<section id="step-5-construct-the-markov-trace-for-the-nh-strategy" class="level2">
<h2 class="anchored" data-anchor-id="step-5-construct-the-markov-trace-for-the-nh-strategy">Step 5: Construct the Markov Trace for the NH Strategy</h2>
<p><em>Use the transition probability matrix to fill out the Markov trace for the NH strategy.</em></p>
<p>Our objective here is to fill out the Markov trace, which is the table that tracks the cohort as it moves through the various health states over time. In principle, we could track a cohort of any size (e.g., 100,000 people; 1,000,000 people, etc.). However, to simplify calculations of the average cost and health outcomes, we will model a cohort of size 1.0. You can see this in the first row of the Markov trace—this row shows that our model will start with a cohort of 1 patient who begins in the “Healthy” state.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/cs_markov-markov-trace.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="images/cs_markov-markov-trace.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></a></p>
</figure>
</div>
<p>You objective here is to fill in each row of the Markov trace. To do this, you must multiply the fraction of the cohort in each state by the transition probability for that state. For example, in the first row, we have 1.0 patients in the Healthy state. Suppose the transition probability from Healthy to Healthy is 0.95. In that case, the number of patients who will remain in the Healthy state in the next cycle is 1.0 x 0.95 = 0.95.</p>
<p>Simliarly, suppose the transition probability for Healthy -&gt; Sick is 0.05. In that case, the number of patients who will transition from Healthy to Sick in the next cycle is 1.0 x 0.05 = 0.05.</p>
<p>The trick here is to incorporate <em>all</em> the possible transitions into each state. For example, in each cycle, the DeathBG state must include all transitions from Healthy -&gt; DeathBG, Sick -&gt; DeathBG, and Sicker -&gt; DeathBG, as well as all the individuals who remain in the death state (i.e., DeathBG -&gt; DeathBG).</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>You can fill out each cycle’s values using formulas that refer to the previous cycle’s values. For example, the value for Healthy in cycle <span class="math inline">\(t=2\)</span> can be calculated using the formula:</p>
<p><code>Healthy[t=2]=Healthy[t=1]*Pr(Healthy-&gt;Healthy)+Sick[t=1]*Pr(Sick-&gt;Healthy)+Sicker[t=1]*Pr(Sicker -&gt; Healthy)+DeadBG[t=1]*Pr(DeadBG -&gt; Healthy)+DeadDisease[t=1]*Pr(DeadDisease-&gt;Healthy)</code>. Note that some of these probabilities will be zero, as shown in the transition probability matrix.</p>
<p>This formula takes the value for Healthy in cycle 1 and multiplies it by the transition probability for Healthy -&gt; Healthy. It then adds the value for Sick in cycle 1 multiplied by the transition probability for Sick -&gt; Healthy, and so on.</p>
</div>
</div>
</section>
<section id="step-6-construct-the-markov-trace-for-the-remaining-strategies" class="level2">
<h2 class="anchored" data-anchor-id="step-6-construct-the-markov-trace-for-the-remaining-strategies">Step 6: Construct the Markov Trace for the Remaining Strategies</h2>
<p><em>Please fill out the complete Markov trace in each of the remaining strategy worksheets.</em></p>
<p><br> <br> <br> <br> <br> <br> <br> <br> <br></p>
</section>
<section id="step-7-calculate-cycle-adjustment-factors" class="level2">
<h2 class="anchored" data-anchor-id="step-7-calculate-cycle-adjustment-factors">Step 7: Calculate Cycle Adjustment Factors</h2>
<p><em>This step will be covered live as a group.</em></p>
<section id="discounting" class="level3">
<h3 class="anchored" data-anchor-id="discounting">Discounting</h3>
<p>Discounting formula:</p>
<p><code>EXP(-r_Delta_t *Cycle)</code> where <code>r_Delta_t</code> is the discount rate and <code>Cycle</code> is the cycle number.</p>
</section>
<section id="cycle-adjustments" class="level3">
<h3 class="anchored" data-anchor-id="cycle-adjustments">Cycle Adjustments</h3>
<p>We’ll use a half cycle adjustment set to 0.5 in the first cycle and 0.5 in the last cycle.</p>
</section>
<section id="total-cycle-adjustment" class="level3">
<h3 class="anchored" data-anchor-id="total-cycle-adjustment">Total Cycle Adjustment</h3>
<p>The total cycle adjustment is the product of the discounting and half-cycle adjustment factors.</p>
</section>
</section>
<section id="step-8-calculate-adjusted-cycle-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="step-8-calculate-adjusted-cycle-outcomes">Step 8: Calculate Adjusted Cycle Outcomes</h2>
<p><em>These steps will be covered live as a group.</em></p>
<section id="cycle-costs" class="level3">
<h3 class="anchored" data-anchor-id="cycle-costs">Cycle Costs</h3>
<p>Cycle costs are calculted by multiplying the cycle value for each health state by its associated cost payoff. For example, if the cost of a cycle in the Healthy state is 5 and the value for Healthy in a given cycle is 0.25 (i.e., 25% of the cohort is in the Healthy state for the cycle), the Healthy costs for the cycle would be 5 * 0.25 = 1.25. We can similarly calculate the costs for the other health states in the cycle. The sum of these costs, multiplied by the cycle adjustment factor, is the adjusted total cost for the cycle.</p>
</section>
<section id="cycle-qalys" class="level3">
<h3 class="anchored" data-anchor-id="cycle-qalys">Cycle QALYs</h3>
<p>Cycle QALYs are constructed much like costs. The only exception is that we multiply by the utility weight rather than the cost for the given health state. Remember to also multiply by the total adjustment factor for the cycle, in order to obtain discounted and cycle-adjusted total QALYs.</p>
</section>
<section id="cycle-ylds" class="level3">
<h3 class="anchored" data-anchor-id="cycle-ylds">Cycle YLDs</h3>
<p>Cycle QALYs are constructed much like costs. The only exception is that we multiply by the disability weight rather than the cost for the given health state. Remember to also multiply by the total adjustment factor for the cycle, in order to obtain discounted and cycle-adjusted total YLDs.</p>
</section>
<section id="cycle-ylls" class="level3">
<h3 class="anchored" data-anchor-id="cycle-ylls">Cycle YLLs</h3>
<ol type="1">
<li><p>We begin with remaining (undiscounted) life expectancy at each cycle, which is based on the age of the cohort at the beginning of each cycle, and drawn from the <a href="https://ghdx.healthdata.org/record/ihme-data/global-burden-disease-study-2019-gbd-2019-reference-life-table">reference life table published by the GBD</a>.</p></li>
<li><p>Per the GBD formulas and WHO guidance (which recommends discounting health outcomes in CEAs), we next discount the remaining life expectancy at each cycle so that it reflects the present value of remaining life expectancy. This is done using the following continuous time discounting formula: <code>(1/r_ann) * (1 - EXP(-r_ann * LE))</code>, where <code>r_ann</code> is the annual discount rate (e.g., 3%) and <code>LE</code> is the value for undiscounted remaining life expectancy for the cycle.</p></li>
<li><p>Next, we must determine the total number/fraction of the cohort that dies <em>due to CVD-related causes</em> in each cycle. This is done by subtracting the value for <code>DeadDisease</code> in the previous cycle from the value for <code>DeadDisease</code> in the current cycle. For example, if the value for <code>DeadDisease</code> in cycle 1 is 0.05 and the value for <code>DeadDisease</code> in cycle 2 is 0.10, then the number/fraction of the cohort who die due to CVD-related causes in cycle 2 is 0.10 - 0.05 = 0.05.</p></li>
<li><p>To calculate the YLLs, we multiply the discounted remaining life expectancy value by the number/fraction of the cohort who die due to CVD-related causes in the cycle. These are the values we calculated directly above.</p></li>
</ol>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>To calculate YLLs, we must also apply the half cycle correction to ensure more accurate total values. Note that we do <em>NOT</em> apply the total cycle correction factor (which we applied to the cost, QALY, and YLD outcomes) because we already applied discounting in Step 2 above.</p>
</div>
</div>
</section>
</section>
<section id="step-9-total-expected-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="step-9-total-expected-outcomes">Step 9: Total Expected Outcomes</h2>
<p><em>This step will be covered live as a group.</em></p>
<p>We next calculate the sum of costs, QALYs, YLDs, and YLLs. Total DALYs is calculated by adding together total YLDs and total YLLs.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Use the variable names supplied to define names for each of the outcomes. This will facilitate easily incorporating outcomes from all strategies when we calculate ICERs in the next section. See the figure below–the variable names are stored in the top row.</p>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/cs_markov-outcomes.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="images/cs_markov-outcomes.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></a></p>
</figure>
</div>
</section>
<section id="step-10-perform-incremental-cost-effectiveness-analysis" class="level2">
<h2 class="anchored" data-anchor-id="step-10-perform-incremental-cost-effectiveness-analysis">Step 10: Perform Incremental Cost-Effectiveness Analysis</h2>
<p><em>This step will be covered live as a group.</em></p>
<p>The worksheet <code>CEA</code> provides tables for calculating incremental cost effectiveness ratios (ICERs) (i.e., cost per DALY averted). Enter the various outcomes for each strategy to fill out the top table. Then, sort by cost and calculate ICERs, dominated strategies, etc. as we did in lecture, and in the ICER case study.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>In reality, transition probabilities would be expected to change over time as the population ages and as the prevalence of risk factors changes. For example, the risk of developing CVD is likely to increase with age, and the risk of developing CVD is likely to increase with the prevalence of risk factors such as obesity and diabetes. We will ignore these changes for the sake of simplicity. This simplifying assumption means that we are fitting a “time-homogeneous” model. In reality, we would expect the model to be “time-inhomogeneous” (i.e., the transition probabilities change as the cohort ages).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"openEffect":"zoom","closeEffect":"zoom","loop":false,"selector":".lightbox","descPosition":"bottom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>